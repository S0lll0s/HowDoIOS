; proc.dasm: process management syscalls
;
; This file is part of HowDoIOS.
; Visit our git repo at https://github.com/S0lll0s/HowDoIOS
;  Copyright (C) 2013 S0lll0s

; PROC_EXIT (0xf010)
; terminates the current (calling) process
:_proc_exit
	SET PEEK, [_tasking_current_pid] ; Current Process ID
	RFI 0

; PROC_GETID (0xf011)
; returns pid of the calling process (A)
:_proc_getid
	SET PEEK, [_tasking_current_pid] ; directly set [SP] (stored A)
	RFI 0

; PROC_FORK (0xf012)
; copies the calling process. returns the child pid in the main, 0 in the child process
:_proc_fork
	; allocate new memory in current process size
	; copy process
	; duplicate entry in processes
	; set A to 0 in child register entries
	SET PEEK, 0 ; A: Child Pid
	RFI 0

; PROC_KILL (0xf013)
; terminates process with pid in A
:_proc_kill
	SET A, POP
	SET PUSH, X
	SET PUSH, Y
	JSR _mem_free_pid ; free process' dynamically allocated memor
	; TODO: call cleanup handler of imported drivers??
	; remove from multitasking list
	SET Y, [_tasking_current_task]
:.loop
	SET X, Y
	SET Y, [X+1] ; go one step further
	IFN [Y], A ; not the one we search for
		SET PC, .loop
	SET [X+1], [Y+1] ; Y is the one to delete, so set the parent's successor to [Y+1]
	SET [_tasking_current_pid], [Y] ; set this so we can just
	SET [_tasking_current_task], Y ; load
	SUB [_tasking_num_tasks], 1
	SET A, Y ; free the task info
	JSR _mem_alloc_memory
	SET Y, POP
	SET X, POP
	SET PUSH, 0 ; push 0 as the EX register... we're losing this one :/
	SET PC, _tasking_load_only ; load the next proc's registers

; PROC_EXEC (0xf014)
; loads an executable from the memory starting at A, returns pid (or 0 for errors) in A 
:_proc_exec
	SET A, POP
	JSR _proc_new_task
	SET PEEK, A
	RFI 0
	
:_proc_new_task
	SET PUSH, X
	SET PUSH, Y
	SET PUSH, A ; source

	IFN [A], 0x4110	; wrong magic
		SET PC, .error3
	
	IFN [A+1], 0x0100 ; incompatible version
		SET PC, .error3

	SET Y, 0xf000 ; new pid TODO: find new pid

	SET A, B
	SET B, Y
	JSR _mem_alloc_memory
	
	IFE A, 0		; failed to allocate memory
		SET PC, .error3
	
	SET C, A		; destination
	SET A, POP		; peek at source
	SET PUSH, C		; save destination
	SET B, A		; start
	ADD B, [A+2]	; + header size 
	ADD B, [A+3] 	; + code size = end
	JSR __memcpy
	
	SET A, PEEK		; restore destination
	SET B, A
	ADD B, 7		; skip to reloc table + 1
	ADD A, [A+2]
	SET PUSH, A		; save begin of code segment
	SET C, [B-1]	; num entries
	
:.relocl
	IFE C, 0
		SET PC, .relocd
	SET A, PEEK
	SET X, A
	ADD A, [B]
	ADD [A], X
	
	SUB C, 1
	ADD B, 1
	SET PC, .relocl
	
:.relocd
	ADD B, 2 ; skip over num_exports
	
	SET C, [B-1]
	; TODO: for each export:
:.exportl
		IFE C, 0 ; done with exports
			SET PC, .exportd
		SET A, _dependency_exports
:.inner_exportl
		IFN [A], [B] ; this is not the right interface
			SET PC, .inner_exportn
		IFE [A+2], 13 ; max exporters	TODO: one more nested list for infinite exporters
			SET PC, .exportn
		ADD [A+2], 1 ; increase num_exporters
		ADD A, [A+2]
		ADD A, 3
		SET [A], Y ; append pid to exporters
		SET PC, .exportn
		
:.inner_exportn
		IFE [A+1], 0 ; end of list
			SET PC, .inner_exportf
		SET A, [A+1]
		SET PC, .inner_exportl
		
:.inner_exportf ; else:
		SET PUSH, B
		SET PUSH, A ; save end of list
		
		SET A, 0x10 ; create new node
		SET B, 0 ; pid = OS
		JSR _mem_alloc_memory
		
		IFE A, 0
			SET PC, .exporterr
		
		SET [A], [B]
		SET [A+1], 0
		SET [A+2], 1
		SET [A+3], Y
		
		SET B, POP
		SET [B+1], A ; connect to former end of list
		
		SET B, POP
		
:.exportn
	SUB C, 1
	ADD B, 1

:.exportd
	; imports and exported variables are handled when the program accesses them (DEP_LOAD)

	ADD [_tasking_num_tasks], 1
	SET A, 0x10 ; process info = 16 words
	SET B, Y ; pid
	JSR _mem_alloc_memory
	
	IFE A, 0
		SET PC, .lasterr
	
	; set the registers
	SET [A], B			; pid
	SET C, [_tasking_current_task]
	SET [A+1], [C+1]
	SET [C+1], A		; put the new task between this one and the next
	SET C, POP			; header start
	SET [A+0x2], 0
	SET [A+0x3], 0
	SET [A+0x4], 0
	SET [A+0x5], 0
	SET [A+0x6], 0
	SET [A+0x7], 0
	SET [A+0x8], 0
	SET [A+0x9], 0
	SET [A+0xa], [C+5]	; entry point
	SET [A+0xc], 0
	SET [A+0xd], 0
	SET [A+0xe], C	  	; header
	SET [A+0xf], 0  	; flags
	IFE [C+0x5], 0xffff	; no entry = lock
		SET [A+0xf], 1
	
	SET X, A ; backup the task info
	
	SET A, 0x40 ; 64 words of stack is enough... hopefully
	SET B, Y ; pid
	JSR _mem_alloc_memory
	ADD A, 0x3f ; go to the end of the stack memory
	SET [X+0xb], A ; set SP
	
	SET A, Y ; new pid
	SET B, X ; info location
	SET Y, POP
	SET X, POP
	SET PUSH, A
	RFI 0
	
:.exporterr
	ADD SP, 2
:.lasterr
	SET A, Y
	JSR _mem_free_pid
:.error3
	ADD SP, 1
:.error2
	SET Y, POP
	SET X, POP
	SET PUSH, 0 ; return 0
	RFI 0

; PROC_SKIP (0xf015)
; skips current process / slice (give other processes more time)
; is directly mapped to _tasking_next_slice, see handler.dasm